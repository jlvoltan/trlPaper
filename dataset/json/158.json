{
    "id": 158,
    "titulo": "implementação em pld de máquinas de estados finitos assíncronas de relógio local",
    "autor": "duarte l. oliveira, diego bompean, tiago curtinhas, lester a. faria, noé alles e leonardo romano",
    "url": "https://www.sige.ita.br/edicoes-anteriores/2012/st/P_7.pdf",
    "tipo_documento": "Artigo de Simpósio",
    "rotulo": 1,
    "resumo": "Controladores baseados em máquinas de estado finito (MEF) síncronas são grandemente usados para projeto da unidade de controle em um sistema digital embarcado (SDE). Estes sistemas possuem requisitos críticos, tais como consumo de potência, robustez, velocidade, etc. O paradigma assíncrono possui características interessantes que pode ser uma alternativa para este projeto. Neste artigo propomos um método para projeto de MEF assíncrona no estilo de relógio local. Este estilo reduz os requisitos da lógica assíncrona e viabiliza a síntese em dispositivos programáveis (Programmable Logic Device – PLD). As PLDs são uma alternativa de projeto rápido e de custo reduzido e são bastante difundidas no projeto SDE. O nosso método parte de uma especificação popular denominada modo rajada estendida (extended burst-mode – XBM) e usa as técnicas do paradigma síncrono para realizar a síntese.",
    "texto": " I. INTRODUÇÃO Sistemas digitais embarcado podem requerer alta capacidade de integração, alta velocidade e baixo consumo de energia [1]. Eles podem necessitar de baixa interferência eletromagnética, serem robustos aos efeitos radiativos, como também a variações de temperatura e de tensão de alimentação. Um caminho que pode satisfazer os requisitos do ambiente embarcado é a implementação destes sistemas na tecnologia PLD (Programmable Logic Device), nos dispositivos: CPLD (complex PLD) e FPGA (Field Programmable Gate Array) [2,3]. Os dispositivos FPGAs tornaram-se um meio popular de implementar circuitos digitais. Tecnologia FPGA tem crescido consideravelmente nos últimos anos, gerando FPGAs de até 50 milhões de portas, permitindo assim que sistemas digitais complexos possam ser programados em tais dispositivos [3,4]. FPGAs de alto desempenho são implementados na tecnologia MOS Deep-Sub-Micron (MOS-DSM). Essa tecnologia necessita operar com baixo ruído e a diferença entre o atraso máximo e mínimo nas linhas, portas é maior quando comparado com outras tecnologias MOS, e o atraso em uma linha pode ser maior que o atraso em uma porta [5]. Sistemas digitais síncronos usam um sinal de relógio global para sincronizar as suas operações e são bastantes populares devido à simplicidade de projeto. Também há uma oferta abundante de ferramentas CAD comercial para síntese automática. Um sério problema na tecnologia MOS-DSM é conviver com o sinal de relógio global, porque ele é um grande causador de ruído, de alta emissão eletromagnética, consome uma parte significativa da potência e definir a distribuição do sinal de relógio é uma tarefa com complexidade crescente (por exemplo: relógio defasado – clock skew). Análise de temporização de circuitos digitais MOS-DSM síncronos de alta integração é extremamente difícil. Uma característica comum nos sistemas eletrônicos embarcados é o fato de serem alimentados por bateria. Como são alimentados por bateria é desejável que as baterias tenham uma longa vida útil, portanto a potência dissipada é um parâmetro muito importante na concepção de tais sistemas [6]. Em um sistema digital á parte seqüencial é o principal contribuinte para a dissipação de potência dinâmica. Estudos recentes têm mostrado que em tais sistemas o relógio consome uma grande porcentagem (15% a 45%) da potência do sistema. Uma interessante alternativa para projeto digital embarcado, porque ele elimina os problemas causados pelo sinal de relógio e aumenta a robustez é o paradigma assíncrono. A. Sistemas digitais assíncronos Sistemas assíncronos operam por eventos não possuem um sinal global que sincroniza as operações. A sincronização é realizada por protocolos do tipo Handshaking. No projeto de sistemas digitais assíncronos temos que definir o estilo de projeto, e em qual classe o circuito vai operar corretamente. A classe define o modelo de atraso e em que modo de operação o circuito se comunica com o ambiente [7]. Os circuitos assíncronos podem ser classificados em duas classes: a) portas e linhas com atrasos delimitados (bounded gate and wire delay – BGWD); b) portas e linhas com atrasos quaisquer (indefinidos), mas finitos (unbounded gate and wire delay – UGWD). Um importante circuito assíncrono que obedece ao modelo BGWD é o modo-rajada e extensões (burst-mode circuits) [8,9]. O circuito insensível ao atraso (delay insensitive circuits – DI) obedece ao modelo UGWD [7]. Este modelo é o mais robusto e isento de qualquer análise de temporização. Martin [10] mostra que a aplicação deste modelo é muito restrita. Existe variantes menos restrita deste modelo de atraso, como os circuitos independentes da velocidade (speed independent circuits – SI) e os circuitos quase insensíveis ao atraso (quasi delay insensitive circuits - QDI) [7]. A comunicação do circuito com o ambiente ou é realizada no modo fundamental generalizado (MFG) (por exemplo: modo-rajada) [8] ou no modo Entrada/Saída (M_E/S) (por exemplo: DI, SI, QDI) [7,11,12]. No MFG a mudança de um novo conjunto de entradas o circuito deve estar estabilizado. No M_E/S a mudança de um sinal de saída pode imediatamente habilitar a mudança de um sinal na entrada. No aspecto do projeto assíncrono há três diferentes estilos: a) decomposição do tipo controlador + data-path [13]; b) micropipeline [14]; c) composição com macromódulos [15]. Os três estilos podem ser projetados nas diferentes classes de circuitos assíncronos. O estilo de projeto assíncrono por decomposição é familiar aos projetistas e é voltado para aplicações de controle intensivo. Ele tem duas variantes: a) projetos que envolvem data-path assíncrono, portanto sem qualquer inserção de elementos de atraso. A especificação denominada STG (signal transition graph – Petri-net) é a mais apropriada para descrever o controlador, que vai interagir com o data-path assíncrono [11]. O datapath assíncrono envolve componentes dual-rail, que tem um custo muito alto; b) projetos que envolvem data-path síncrono, um elemento de atraso é inserido e ele define o tempo de ciclo da transição de estado (ver Fig. 1). A especificação denominada modo rajada estendida (extended burst-mode – XBM) é a mais apropriada para descrever o controlador (máquina de estado finito assíncrona – MEFA), e que vai interagir com o data-path síncrono [16]. A variante (b) implica em circuitos com menor consumo de potência, menor área e simplifica o projeto quando comparado com a variante (a). Em anos recentes, alguns circuitos assíncronos da vida real foram projetados com sucesso e eficientemente baseados nas MEF assíncronas modo rajada estendido (MEFA_XBM) [17-19]. Neste trabalho nós focamos o projeto das MEFA_XBM. Dois são os pontos fracos de MEF assíncronas: dificuldade no projeto e poucas ferramentas para síntese automática. A dificuldade do projeto é que o circuito deve ser livre de risco (hazard) e de corrida crítica [7]. O projeto deve satisfazer os diferentes tipos de risco, como: funcional, lógico e seqüencial. O projeto de MEFA_XBM pode ser sintetizado em diferentes arquiteturas. Uma interessante arquitetura é a de relógio local, porque reduz os requisitos da lógica assíncrona [8,20-28]. Os métodos propostos em [8,26,27] para relógio local estão voltados para a especificação BM que é limitada para descrever interação com data-path síncrono. Outras restrições estão na minimização de estados e na minimização lógica, onde as equações de saída devem ser livres de risco lógico [8]. Neste artigo introduzimos um novo método para síntese de MEFA_XBM com relógio local. O nosso método parte da especificação XBM e usa o paradigma síncrono de síntese de MEF síncrona de saída direta. O nosso método projeta a MEFA_XBM como uma MEF síncrona de saída direta, portanto usa ferramentas do paradigma síncrono. O sinal de relógio é substituído por uma função Booleana combinatória que gera localmente o sinal relógio. No nosso relógio somente há transição, quando um conjunto de sinais de entrada (rajada) rotulados em uma transição de estado for ativado, portanto reduz a atividade do relógio. A única restrição é que á função geradora de relógio tem que ser livre de risco lógico. As MEFA_XBM de relógio local sintetizadas pelo nosso método são implementadas na arquitetura da Fig. 2. Elas podem ser sintetizadas em qualquer PLD, como CPLDs e FPGAs sem a necessidade de satisfazer qualquer tipo de mapeamento de macro-células. Como restrições, devemos inserir um elemento de atraso para garantir o tempo de setup dos FFs e a função combinatória geradora de relógio necessita de uma cobertura livre de risco lógico. II. VISÃO GERAL: MÁQUINAS DE ESTADO FINITO Máquinas de estado finito são grandemente usadas no projeto de sistemas digitais. Elas se apresentam em diferentes modelos, são usadas nos diferentes paradigmas de projeto, são sintetizadas em diferentes arquiteturas e implementadas em diferentes tecnologias. A. Máquinas de estado finito assíncronas em PLDs O paradigma de projeto envolvendo PLDs é bastante popular para prototipagem e produção de circuitos digitais, isto é devido ao seu baixo custo e tempo curto de projeto. O seu foco tem sido circuitos digitais síncronos. Houve alguns recentes esforços para prototipagem assíncrona. Ela foi realizada em FPGAs comerciais [29] e FPGAs assíncronas acadêmicas [30]. Existem duas razões porque FPGAs comerciais têm dificuldades em implementar MEF assíncronas: a. Processo de mapeamento de funções Booleanas livre de risco em blocos lógicos (macro-células) pode introduzir risco lógico. As ferramentas comerciais de decomposição e mapeamento em FPGAs baseadas em look-up tables (LUTs) não estão preparadas para decomposição das funções Booleanas livre de risco lógico. A decomposição lógica deve satisfazer os requisitos propostos em [31]. b. Processo de roteamento interno entre blocos lógicos pode introduzir atrasos significativos que pode resultar em risco seqüencial do tipo essencial. Este tipo de risco pode ser solucionado por inserção de elementos de atraso nas linhas de realimentação ou se a especificação satisfaz o requisito de sinal essencial [32]. B. MEF assíncronas de relógio local Muitas propostas de MEF assíncronas de relógio local (MEF_RL) foram introduzidas nas últimas quatro décadas [20-28]. As MEF_RL também conhecidas como máquinas auto-sincronizadas, são máquinas que geram um simples relógio local. O objetivo destas propostas era permitir múltiplas mudanças de entrada (multiple input chance – MIC) e reduzir os requisitos da lógica assíncrona. A maior parte das propostas gera circuitos lentos e grandes inviabilizando as aplicações reais. Estas propostas são baseadas ou em flip-flops não convencionais e/ou no uso excessivo de elementos de atraso. Nowick em seu PhD [8] propõe uma síntese automática que parte da especificação modo rajada (burst-mode (BM) specification) e implementa na arquitetura de relógio local baseada em latches (ver Fig. 2). Esta especificação suporta uma classe de MIC. As vantagens são: o relógio somente é ativado quando há mudança de estado e o elemento de memória é baseado em latches. Elementos de atraso podem ser necessários para solucionar problemas de temporização. Nowick em [33,34] aplica em casos reais e mostra a eficiência do seu método. C. Arquitetura com saída direta Um interessante tipo de MEF síncrona foi descrito em [35,36]. Ela é conhecida como MEF síncrona com saída direta (MEFS_SD), onde os sinais de saída são usados como sinais de estado (ver Fig. 4). Quando comparemos com os modelos tradicionais Moore e Mealy, temos: a) Pomeranz et al. [35] mostra o potencial das MEFS_SD, como redução do tempo de latência, área e eliminação dos glitches nos sinais de saída; b) Valeri [36] mostra que as MEFS_SD ocupam um menor número de macro-células em uma PLD. Há duas vantagens usando sinais de saída como sinais de estado: • Redução ou eliminação das variáveis de estado, portanto podemos ter redução de área. Também aumentamos a observabilidade e a controlabilidade, que permite facilitar a testabilidade; • Na execução clássica das máquinas modelo Moore há três blocos (lógica de excitação, flip-flops, lógica de saída). Nas máquinas de saída direta há somente dois blocos (lógica de excitação e flip-flops), portanto há uma redução no tempo de ciclo (aumento de taxa de relógio); III. ESPECIFICAÇÃO MODO-RAJADA ESTENDIDA Nowick [8] propôs uma especificação denominada modo rajada (burst-mode – BM). Transições podem ocorrer quando uma ou múltiplas entradas mudam seu nível lógico, 0→ 1, ou 1 → 0 (sinais sensíveis á transição – TSS). Quando não há nenhuma mudança na entrada à máquina permanece em seu estado estável. As rajadas devem ser monotônicas, isto é, elas podem mudar somente uma única vez durante a cada transição. Um estado inicial deve existir. Na especificação BM, a transição de estado é rotulada com entrada rajada / saída rajada, onde a saída rajada pode ser vazia e somente sinais rotulados podem mudar. A especificação BM deve satisfazer três propriedades para ter condições de implementação [8]: 1. Polaridade dos sinais, que é a comutação da transição do sinal {+,−}; 2. Ponto de entrada única; 3. Conjunto máximo. Yun [9,16] propôs a especificação modo rajada estendida (extended burst-mode – XBM) adicionando duas características: sinais irrelevantes direcionados (directed don’t-care), que permite um sinal mudar concorrentemente com os sinais de saída e sinais condicionais, que depende do nível do sinal (level sensitive signals– LSS) com comportamento não monotônico. As restrições mencionadas acima foram generalizadas para permitir a extensão proposta por Yun em seu PhD [9]. Nós ilustramos a especificação com o benchmark SCSI. Fig. 5 mostra uma especificação XBM do SCSI com 4 entradas (Cntgt1, Fain, Ok, Rin), 2 saídas (Aout, Frout) e estado inicial 0. A descrição Rin+ Fain- / Aout+ na transição 5→3 significa que a saída (Aout: 0 → 1) vai ser ativada quando a entrada rajada for ativada (Rin: 0→1 AND Fain: 1→0). O sinal LSS cntgt1 é usado para descrever a exclusão mútua entre as transições 3→6 e 3→4. O sinal irrelevante direcionado Rin* na transição 4 → 5 significa que o sinal Rin pode ou alterar o seu valor ou permanecer no seu antigo valor. Todo a transição de estado deve ter pelo menos um sinal de entrada denominado de compulsory. Um sinal de entrada é compulsory se na transição de estado anterior, ele não é irrelevante direcionado. IV. FUNÇÃO GERADORA DE RELÓGIO A função geradora de relógio fGR tem que ser livre de conflito (GR_LC). Nesta seção introduzimos o conceito de conflito para a função fGR. O conflito está relacionado quando duas ou mais transições de estado que contêm estados em comum, mas com valores de saída da função fGR diferentes. Formalmente definimos conflito como: Definição 1: Conflito. Seja as transições de estado Ti e Tj quaisquer de uma especificação XBM da função fGR com os respectivos cubos de transição Ti[A,B] e Tj[C,D]. Diz-se que há um conflito na fGR entre Ti e Tj se e somente se: 1. A∩C≠∅ ou A∩D≠∅ ou B∩C≠∅ ou B∩D≠∅. 2. Existe um estado K∈[Ti,Tj] fGR(Ti-K)≠0 ou fGR(Tj-K)≠0. A definição de conflito usa o conceito de cubo de transição. Fig. 6a,b mostram respectivamente uma especificação BM e a sua descrição na tabela verdade. Este exemplo possui cinco conflitos na função fGR. O cubo de transição na transição de estado 0 →1 é descrito pelos cubos de entrada A=a,b,x,y=2200, onde 2 significa don’t-care e cubo de saída B=a,b,x,y=1122. Para solucionar os conflitos usamos o algoritmo baseado na proposta por Yun et al. [9]. Figura 7 mostra uma tabela verdade para cada transição de estado da especificação BM. Figura 8 mostra a fusão de tabelas que obedece a definição 2. Figura 9 mostra a tabela verdade final, onde necessitou de duas variáveis de estado para eliminar os cinco conflitos. A função combinatória minimizada fGR é obtida usando o algoritmo proposto em [9]. V. METODOLOGIA: SÍNTESE DE MEFA COM RL A nossa metodologia para síntese de MEFA_RL está voltada para implementação em PLDs, portanto a nossa arquitetura usa flip-flops D como elemento de memória (ver Fig. 1). A metodologia tem quatro passos e parte da especificação XBM: 1. Usando o procedimento da seção IV extrair a função fGR de relógio livre de conflitos e de risco lógico (GR_LCR). 2. Se houve inserção de variáveis na função GR_LCR reformular a especificação XBM, caso contrário ir para o passo 3. 3. Sintetizar a especificação XBM como uma MEF síncrona de saída direta usando o método em [35]. 4. Substituir o sinal de relógio pela função GR_LCR e calcular o elemento de atraso para satisfazer o tempo de setup. Figura 10 mostra a especificação BM reformulada obtida da especificação original e da tabela da Fig. 9. Figura 11 mostra a tabela de transição de estados da especificação BM reformulada que está voltada para o paradigma síncrono, no caso MEFS de saída direta. A máquina é inicializada no estado 0 (abQ1Q2xy=000000). Figura 11 mostra o elemento de atraso assimétrico próprio para os compiladores de PLDs. VI. CASO DE ESTUDO Para ilustrar o nosso método usamos a especificação XBM descrita em Fig. 5 do controlador de barramento SCSI (small computer systems interface) como definido pela ANSI standard X3.131-1986 que é um protocolo físico e lógico para comunicação entre computadores e dispositivos periféricos [17]. Figuras 13, 14 e 15 descrevem o passo 1 que é gerar a função fGR livre de risco lógico e de conflitos. Como houve quatro conflitos a especificação necessitou de duas variáveis de estado (Q1 e Q2) para eliminá-las. Figura 16 mostra a especificação XBM reformulada obtida no passo 2. Figuras 17 e 18 mostram a síntese no paradigma síncrono da MEF que foi obtida no passo 3. VII. DISCUSSÃO & SIMULAÇÃO O projeto digital que estamos tratando está voltado para PLDs. A nossa arquitetura é baseada em flip-flops D e não em latches, porque nestes dispositivos a lógica combinatória e o flip-flop D estão na mesma macro-célula, portanto se obtêm um melhor desempenho e redução de LUTs. Para aplicações que são descritas pela especificação BM a função fGR pode ser obtida por uma cobertura lógica convencional, isto é usando a minimização lógica do paradigma síncrono. As MEFA_XBM_RL interagem com o ambiente no MFG. A nossa MEFA_XBM_RL foi simulada compilada na ferramenta ALTERA, software QUARTUS II, versão 9.1, família CYCLONE III, e dispositivo EP3C16F484C6. Figura 19 mostra as formas de onda livre de risco extraídas da simulação do benchmark SCSI e que foi sintetizado na seção VI. Figura 20 mostra os tempos de latência de cada transição de estado. O nosso circuito ocupou 16 LUTs e 6 flip-flops D, onde 2 flip-flops foram usados no elemento de atraso. VIII. CONCLUSÃO Neste artigo introduzimos um novo método para síntese MEFA_XBM. Este método sintetiza no estilo de relógio local, isto permite reduzir os requisitos da lógica assíncrona, que é importante quando se pretende implementar em PLDs. A MEFA_XBM é toda sintetizada no paradigma síncrono, somente a função geradora de relógio requer um procedimento, que sintetiza a função livre de conflitos e de riso lógico. Trabalhos futuros propor um ambiente voltado para PLD para síntese automática de MEFA_XBM_RL e propor uma função geradora de relógio robusta que aceita qualquer cobertura lógica. "
}