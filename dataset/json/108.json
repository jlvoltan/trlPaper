	{
		"id": 108,
		"titulo": "síntese de contadores síncronos de alta latência baseados em latches transparentes",
		"autor": "duarte l. oliveira, tiago curtinhas, lester a. faria, leonardo romano",
		"url": "https://www.sige.ita.br/edicoes-anteriores/2015/st/ST_9_1.pdf",
		"tipo_documento": "Artigo de Simpósio",
		"rotulo": 1,
		"resumo": "A memória da parte sequencial de um sistema digital síncrono convencionalmente é composta por elementos de memória do tipo flip-flops. Esse tipo de elemento de memória além de ter uma alta potência dissipada também tem um tempo de atraso significativo (tempo de setup + tempo de propagação). Um componente sequencial muito importante em um sistema digital são os contadores síncronos. Contadores síncronos são convencionalmente sintetizados a partir de Flip-Flops. Neste artigo propomos um novo método para projeto de contadores síncronos que são sintetizados a partir de latches transparentes. A substituição Flip-Flops por latches transparentes acarretam algumas potenciais vantagens, como redução do tempo de atraso, que significa aumento de desempenho e redução no tempo setup, que aumenta a robustez á metaestabilidade. Através de dois casos de estudo mostramos a simplicidade e a eficiência do novo método, como também uma melhoria nos resultados.",
		"texto": " I. INTRODUÇÃO A fase corrente da microeletrônica, que está em nanômetros (Deep-Sub-Micron – DSM-CMOS) permite o projeto VLSI (Very Large Scale Integration) de sistemas digitais síncronos de alta complexidade, e muitos desses projetos tem com obstáculos a distribuição do sinal de relógio (clock) e exigência de elevado desempenho [1,2]. Na tecnologia DSM-CMOS o atraso nas linhas podem ser maior que o atraso nas portas, como também aumenta a intolerância ao ruído e a interferência eletromagnética [3]. O sinal de clock é o principal causador tanto do ruido como interferência eletromagnética. Finalmente, podemos dizer que na tecnologia DSM-CMOS dois importantes desafios são: a distribuição do clock e resolver o problema de defasagem do clock (clock skew). Muitos sistemas digitais síncronos contemporâneos são descritos por uma arquitetura que consiste de uma rede de controladores + datapaths (ASIC – Application Specific Integrated Circuit) e / ou processadores [4,5]. Os controladores de tais circuitos síncronos são muitas vezes referidos como uma máquina de estado finito (MEF) composta de vários estados e transições entre estados, ou seja, são especificados por um grafo de transição de estados (GTE). Em um sistema digital á parte sequencial é a principal contribuinte para a dissipação de potência dinâmica. Estudos recentes têm mostrado que em tais sistemas o clock consome uma grande percentagem (15% a 45%) da potência do sistema [6]. O sinal de clock atua diretamente nos elementos de memória, do tipo flip-flop ou latch. Os métodos de síntese de MEFs síncronas usam flip-flops (single-edge-transition – SET-FF) para armazenar os estados da máquina, mas este elemento de memória contribui para o problema de clock skew e seu tempo de atraso é significativo (tempo de setup + tempo de propagação) afetando o desempenho [7-9]. Uma alternativa promissora para a síntese de MEFs sincronas de baixo consumo de energia é substituir os flip-flops por latches transparentes. Os latches transparentes quando comparados com os flip-flops têm várias vantagens, tais como: a) o consumo de energia é até um terço menor que os flip-flops [10]; b) área é até um terço menor que os flip-flops [10] (ver Fig. 1); c) problema da defasagem do clock é reduzida; d) os tempos de setup e de propagação são menores; e) Além disso, a menor capacitancia do clock no latch pode reduzir ainda mais o consumo de energia na árvore do clock. Uma vez que a maior parte do consumo de energia em recentes chips é devida à árvore do clock [11]. Diferentes abordagens têm sido propostas para sintetizar MEFs sincronas utilizando latches transparentes. Em [12,13] utiliza uma estratégia de clock de multiplas fases. Em [14]- [17] usam clock de simples fase, mas diferentes estratégias para a substituição de alguns flip-flops por latches. Estas estratégias têm limitações; o uso de multiplas fasses aumenta a complexidade de distribuição do clock e a substituição parcial de flip-flops, conduz a uma otimização subótima do desempenho. Houve algumas abordagens para usar latches em vez de flip-flops para obter esses méritos [12],[18]-[20]. Em [12] mostrou uma economia de energia de até 50% quando os latches foram usados. Mas o uso de esquema de múltiplos clock’s é muito desagradável para projetistas de VLSI. Em [18], elementos de armazenamento implementados com os flip-flops são substituídos com latches se o comportamento do circuito de entrada / saída não é afectada. Em [19] usa a técnica assíncrona para decidir quais flip-flops podem ser substituídos por latches e usa o esquema de clock de fase simples. Em [20] usa a técnica de mapeamento direto no estilo one-hot, onde os latches operam nos dois nívei do clock, permitindo operar com a metade da frequencia, mas tendo a mesma taxa de processamento. Contadores síncronos são importantes componentes em um sistema digital. Eles são MEFs síncronas modelo Moore, que são descritas por um GTE. Os contadores síncronos usam flip-flops como elemento de memória, e uma forma muito simples de usar latches transparentes é substituir os flip-flops por dois latches transparentes operando no estilo mestre escravo. A operação do contador neste estilo permite enxergar o desbalanceamento que ocorre nos níveis alto e baixo do sinal de clock, ocorrendo uma ociosidade em um dos níveis. Neste artigo propomos um novo método baseado no particionamento dos estados para síntese de contadores síncronos. O método proposto sintetiza os contadores síncronos usando como elemento de memória somente latches transparentes, sendo o sinal de clock de simples fase. O nosso projeto permite que os latches transparentes operem na forma balanceada, eliminando a ociosidade em uma das partes do sinal do clock. Os nossos contadores são implementados na arquitetura alvo da Fig. 2. Uma aplicação muito promissora do nosso método quando comparada com a síntese clássica é o projeto de divisores de frequência por um numero impar gerando um sinal de saída com nível simétrico que é baseado em contadores. Através de um caso de estudo mostramos o projeto de um contador reversível com um melhor tempo de latência quando comparado com a síntese clássica. Também mostramos uma aplicação promissora dos nossos contadores, que é o divisor de frequência. O restante deste artigo está organizado da seguinte forma. A seção II discute a síntese clássica dos contadores síncronos; a seção III mostra o procedimento proposto de particionamento e síntese de contadores síncronos; a seção IV apresenta um caso de estudo; a seção V mostra a aplicação do nosso método no projeto de divisores de frequência; seção VI mostra a simulação de dois casos de estudo e resultados; finalmente a seção VII apresenta as nossas conclusões e futuro trabalho. II. SÍNTESE DE CONTADORES: ANÁLISE A síntese clássica de contadores usam flip-flops como elementos de memória. Os tempos de setup e de propagação dos flip-flops são bastante significativos, interferindo significativamente nos tempos de latência e de ciclo dos contadores. Figura 3 mostra o GTE de um contador síncrono reversível módulo quatro. Figura 4 mostra o circuito lógico convencional deste contador, usando flip-flop do tipo D. Figura 5 mostra o mesmo contador, mas usando latches transparentes operando como mestre escravo. A substituição dos elementos de memória não reduz os tempos de latência e de ciclo. O tempo de latência está relacionado com o tempo de atraso que começa com a transição do sinal do clock até a ativação do sinal de saída. O tempo de ciclo está relacionado com o atraso do pior caminho entre dois elementos de memória. Começa no tempo de propagação do primeiro elemento de memória até o tempo de setup do segundo elemento de memória. Figura 6 mostra outra configuração, onde as saídas são obtidas no latch mestre. Nesse caso, há redução substancial no tempo de latência, mas quando há sinais de entrada, no caso o sinal Dir, surge outro problema, que acarreta um aumento drástico do tempo de hold e que é equivalente ao nível alto do sinal do clock. III. ESTILO ME_PARTIÇÃO: CONTADORES O método proposto neste artigo particiona os estados em duas partições (P1,P2), que é visto como o particionamento da memória do contador (ME_Partição). Na partição P1 os estados são armazenados em latches transparentes e ativados no nível alto. Na outra partição P2 os estados são armazenados em latches transparentes ativados no nível baixo. A partição P1 é formada pelo conjunto de estados do grafo de transição de estados (GTE). A partição P2 é formada pelo conjunto de estados NOP (non–operation) inseridos nas transições de estados do GTE, formando um novo GTE, denominado GTE*. Cada partição está relacionada com um semi-codigo, portanto um estado do GTE* é codificado com dois semi-códigos. Eles são chamados de positivo quando relacionado com o clock CLK+ e negativo quando relacionado com o clock CLK–. A concatenação (símbolo usado é &) dos dois semi-códigos formam o código do estado do GTE*. Cada transição de estado do GTE* somente um semi-código pode ser ativado. O assinalamento de estados do GTE* é realizado em duas etapas. Na primeira etapa o semi-código positivo binário dos estados da partição P1, já estão codificados, para o caso dos contadores. A segunda etapa o semi-código negativo binário relacionado com os estados da partição P2 devem ser codificados, independentemente do outro semi-código. O nosso algoritmo de particionamento/assinalamento para os nossos contadores segue três passos: 1. Capturar a descrição do contador síncrono no GTE. 2. Inserir estados NOP em todas as transições de estado do GTE, obtendo um novo GTE (GTE*) e gerar as partições P1 e P2. 3. Realizar o assinalamento de estados NOP no GTE*, no caso a partição P2 e preferencialmente usando o código Gray. Para ilustrar o nosso algoritmo, aplicamos no GTE de um contador reversível modulo oito da Fig. 7. Figura 8 mostra o correspondente GTE* (passo 2). Os estados NOP foram inseridos em todas as transições de estado do GTE, com o símbolo de estados ativados em baixa. Figura 9 mostra o GTE* com os semi-códigos binários. No semi-código positivo de P1 é 8 [0 até 7]. No semi-código negativo é 16 [0 até 15]. (passo 3). A partição P1_CLK+ contém as variáveis de estado Q1, Q2 e Q3, portanto os latches transparentes correspondentes operarão no nível alto do clock. A partição P2_CLK– contém as variáveis de estado Q4, Q5, Q6 e Q7, portanto os latches transparentes correspondentes operarão no nível baixo do clock. A codificação binária do semi-código negativo obedece á distância mínima de Hamming, portanto é uma codificação de baixa potência. A. Método proposto: contadores A nossa metodologia implementa os contadores na arquitetura mostrada na Fig. 1. Ela é composta de quatro passos: 1. Gerar GTE* codificado (seção III) 2. Montar a tabela verdade onde as entradas são as variáveis de estado da partição P2 e as variáveis de saída são as variáveis e estado da partição P1. Extrair a para cada variável de saída a equação Booleana minimizada de próximo estado na forma de soma de produto. 3. Montar a tabela verdade onde as entradas são as variáveis de estado da partição P1 e as variáveis de saída são as variáveis e estado da partição P2. Extrair a para cada variável de saída a equação Booleana minimizada de próximo estado na forma soma de produto. 4. Montar a tabela verdade onde as entradas são variáveis de P1P2 e as saídas se houver são os sinais de saída. Extrair a para cada variável de saída a equação Booleana minimizada soma de produto. IV. CASO DE ESTUDO: CONTADOR REVERSÍVEL Nesta seção, ilustramos o nosso método de síntese com o contador síncrono reversível módulo quatro (ver Fig. 3). O primeiro passo aplica o algoritmo da seção III e gera o GTE* codificado como mostra as Fig. 10 e 11. A codificação binária resultante necessitou na partição P1_CLK+ das variáveis Q1 e Q2 e na partição P2_CLK das variáveis Q3, Q4 e Q5 (ver Fig. 9). Fig. 12 mostra a tabela de transição de estados do contador reversível. Fig. 13 mostra a minimização lógica da partição P2 e Fig. 14 mostra a minimização lógica da partição P1. Fig. 15 mostra o circuito lógico do contrador reversível. V. APLICAÇÃO: DIVISOR DE FREQUÊNCIA Divisores de frequência são importantes no projeto de sintetizadores de frequência. Comunicações sem fio tem recebido um crescente interesse nas aplicações militares e comerciais. As demandas por comutação rápida e frequências de operação elevadas fazem o projeto de sintetizadores de frequência uma tarefa dificil [21-23]. Sintetizadores de frequência pode ser de um tipo inteiro-N com divisores de frequência inteiros programável ou do tipo fracional. Para ilustrar o nosso método, aplicamos no projeto de um divisor de frequência por cinco com saída simétrica (duty cycle 50%). Figura 16 mostra o diagrama de temporização do divisor de frequência desejado. Figura 17 mostra o projeto convencional de um divisor de frequência por cinco com saída simétrica [22]. Para reduzir a lógica de saída, deve-se encontrar uma sequência que mais se enquadra no problema. Como o DF é por cinco, precisamos de um gerador de sequência módulo cinco. No nosso método a frequência de saída é formada por dois geradores de sequencia, portanto a Fig. 18a mostra uma geração de sequencia interessante, para a parte que vai ser ativada no nível alto. A variável Q1 se comporta como um divisor por cinco, mas com 2/3 de duty cycle. Devemos gerar uma sequência para a parte que vai ser ativada no nível baixo, tal que uma variável possa ajustar o duty cycle. Fig. 18b mostra uma sequencia ativada no nível baixo, onde a variável Q4 realiza o ajuste. Fig. 18c mostra a introdução do sinal Fsai no GTE. Usando o método proposto a Fig. 19 mostra o circuito lógico do divisor por cinco. VI. DISCUSSÃO & SIMULAÇÃO & RESULTADOS Contadores síncronos são importantes em um sistema digital. Como são bastante acionados, tem uma tendência de alto consumo de energia. Nas bibliotecas standard cell convencionais os dados de área e desempenho para latches transparentes são reduzidos, quando comparado com flipflops. A substituição de flip-flops por latches traz diversas vantagens no projeto, tais como: a) redução do tempo de setup, o que torna o circuito mais robusto a metaestabilidade [24]; b) aumento da tolerância a clock skew; c) redução de área e potência dissipada. As Figuras 20,21, e 22 mostram a simulação das três diferentes técnicas de projeto de contadores, apresentando os respectivos tempos de latência. As simulações foram realizadas no software da ALTERA QUARTUS II, versão 9.1, na família CYCLONE III, dispositivo EP3C16F484C6N [25,26]. Tabela I traz a análise de área (LUTs + Flip-Flops) e tempo de latência de quatro diferentes implementações no dispositivo FPGA do contador reversível de modulo quatro. A técnica proposta obteve uma redução máxima no tempo de latência de 55% e uma penalidade máxima em área de 225%. no dispositivo FPGA. A potência dissipada obtida nas quatro técnicas praticamente é equivalente. Fazendo uma comparação em VLSI no quesito de área com a síntese convencional e usar como referência os FFs de Fig. 1, onde SET-FFs D são sintetizados com 26 transistores e os latches transparentes com 18 transistores. O nosso método precisou de 110 transistores para o contador reversível, enquanto que o método convencional precisou de 70 transistores, portanto houve uma penalidade de 57%. O projeto de contadores síncronos em VLSI baseados em latches transparentes são promissores para obter alto desempenho no tempo de latência [27]. VII. CONCLUSÃO Neste artigo apresentamos um método para síntese de contadores síncronos baseados em latches transparentes. O novo método também permite sintetizar divisores de frequência de um número impar com frequência simétrica, numa forma elegante e eficiente. Os divisores de frequência sintetizados pelo novo método apresentam um ótimo tempo de latência, alem de uma área reduzida. Para muitos tipos de contadores, este estilo consegue uma redução de área, quando comparado com a síntese convencional. Os contadores síncronos também podem ser usados na implementação de qualquer MEF síncrona. Como trabalho futuro pretendemos aplicar o estilo ME_partição na síntese de processadores programáveis. A grande vantagem do método proposto está na temporização, onde o tempo de hold é zero e o tempo de setup e reduzido."
	}
