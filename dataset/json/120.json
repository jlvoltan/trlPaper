{
    "id": 120,
    "titulo": "uma abordagem prática para projeto otimizado de sistemas digitais assíncronos",
    "autor": "kledermon garcia, duarte l. oliveira, roberto d’amore",
    "url": "https://www.sige.ita.br/edicoes-anteriores/2013/st/P_8.pdf",
    "tipo_documento": "Artigo de Simpósio",
    "rotulo": 1,
    "resumo": "Este trabalho apresenta um método para síntese otimizada de sistemas digitais assíncronos. A proposta usa o estilo de projeto conhecido como decomposição (data-path + controlador), que gera uma descrição intermediária nível RTL (Register Transfer Level). O método proposto emprega a especificação modo-burst estendido para descrever o controlador. Os sistemas assíncronos sintetizados pelo método proposto são capazes de operar no protocolo handshake de duas fases, permitindo um melhor desempenho. Neste método a decomposição é implementada por bundled-data, usando, portanto, componentes do paradigma síncrono. Através de um caso de estudo, mostramos a simplicidade e a eficiência do método proposto.",
    "texto": " I. INTRODUÇÃO Sistemas digitais síncronos usam um sinal de relógio global para sincronizar as operações. Este sinal é uma das principais causas de ruído, emissões eletromagnéticas e consumo de potência. A definição da distribuição do sinal de relógio é uma tarefa complexa devido a sua defasagem ao longo do circuito (clock skew). Sistemas digitais assíncronos não apresentam clock skew e consumo de energia é menor quando comparado com sistemas síncronos equivalentes. Circuitos assíncronos são mais robustos ao ruído e apresentam uma menor emissão eletromagnética [1,2]. A principal desvantagem dos circuitos assíncronos é a dificuldade de serem projetados livres de risco (hazard) e livres de corrida crítica [1,2]. Outro grande problema é a falta de ferramentas confiáveis para seu o projeto. Recentemente, tem havido várias tentativas para demonstrar as vantagens potenciais dos circuitos assíncronos sobre os circuitos síncronos [3-5] e alguns métodos para projeto de sistemas digitais assíncronos têm sido desenvolvidos com sucesso [6]. Neste artigo propomos um método para projeto de sistemas assíncronos otimizados no estilo decomposição bunbled-data, onde o controlador é descrito na especificação XBM (extended burst-mode). O método proposto tem as seguintes características: a) sintetiza o sistema na arquitetura alvo (ver Fig. 1); b) permite a interação com outros módulos no protocolo de 2-Fases (interação ponto a ponto), podendo ser uma estrutura em anel (ver Fig. 2); c) o projeto é todo baseado em portas básicas; d) na síntese comportamental o escalonamento das operações é realizado no paradigma assíncrono; e) elimina as transições de estado mortas que são intrínsecas ao protocolo de 4-Fases. Com exemplo de aplicação, é apresentado o solucionador de uma equação diferencial de segunda ordem pelo método de Euler. Os resultados obtidos foram superiores a outras soluções assíncronas do mesmo problema. Em [3], a solução usa controle distribuído e portas complexas (circuitos transistorizados). A proposta de [7] emprega o escalonamento de operações do paradigma síncrono e, portanto, a solução obtida é sub-ótima. A proposta de [8] usa o protocolo de 4- Fases, que tem um overhead na comunicação, isto é, contém transições de estado mortas.II. SISTEMAS ASSÍNCRONOS Um sistema digital assíncrono pode ser projetado em quatro diferentes estilos: decomposição; micropipeline; composição com macromódulos; e de-sincronização. No primeiro, a decomposição controlador + data-path, pode levar a uma otimização ótima [10-15]. O segundo estilo é interessante para aplicações com natureza pipeline, como microprocessadores, filtros digitais, etc. [16]. O terceiro estilo, também conhecido como método por tradução, é vantajoso em aplicações complexas, mas resulta em circuitos com baixa otimização [6,17-20]. No último estilo, de-sincronização, todo o projeto é realizado no paradigma síncrono, e a conversão gera um alto overhead, com consequente aumento de área e degradação do desempenho [21]. Entre os quatro estilos, o estilo decomposição é muito promissor devido à sua similaridade com o paradigma síncrono (ver Fig. 3). Estilo decomposição para projeto assíncrono Sistemas digitais assíncronos operam por eventos, eles não têm um sinal global para sincronizar as operações. A sincronização dos sinais é realizada por um protocolo handshake (reconhecimento) e o sistema pode ser visto como um bloco funcional que interage com o ambiente através deste tipo de protocolo [1]. O estilo de projeto conhecido como decomposição segue o procedimento clássico dos métodos de projeto VLSI (ver Fig. 4). Os projetos podem ser sintetizados em diferentes classes de circuitos assíncronos, onde a classe define em qual modelo de atraso o circuito irá operar corretamente e o modo de comunicação com o ambiente [1,2]. Este estilo de projeto tem duas variantes. Na primeira, o projeto envolve data-path assíncrono e por isso não apresenta qualquer elemento de atraso. O data-path assíncrono, entretanto, envolve componentes dual-rail, que apresentam um custo elevado de implementação [22]. Na segunda variante, por decomposição, o data-path é implementado no protocolo bundled-data, que envolve componentes single-rail (componentes do paradigma síncrono), e um ou mais elementos de atraso são inseridos no projeto assíncrono para que haja uma comunicação correta entre o controle e o datapath (requisito do modo fundamental) [7,8,10-14]. Esta variante leva a circuitos com baixo consumo de energia, menor área e projeto mais simples, quando comparado com a primeira variante. Duas especificações são comumente usadas para descrever controladores assíncronos, a especificação modo burst estendido (extended burst-mode – XBM) proposta por Yun e Dill [23,24], e a especificação grafo de transição de sinais (signal transition graph – STG) proposta por Chu [25]. A primeira é a mais indicada para controladores que interagem com ambientes do tipo bundled-data, isto é que satisfazem o modo fundamental. A segunda é mais adequada para controladores que interagem com ambientes concorrentes. Para síntese automática, há a ferramenta 3D que sintetiza os controladores XBM [24], e a ferramenta Petrify sintetiza os controladores STG [26]. Um sistema digital assíncrono é visto como um módulo funcional que se comunica com o ambiente (um outro módulo) no protocolo handshake (ver Fig. 5). Este protocolo usa os sinais request (Ri, Ro) e acknowledge (Ai, Ao) para realizar a comunicação. Esta comunicação pode ser no protocolo handshake de quatro fases, onde os dois sinais usam apenas uma borda (ver Fig. 5a), ou no protocolo de duas fases, onde os dois sinais usam as duas bordas na comunicação (ver Fig. 5b). Existem diferentes abordagens propostas para o estilo decomposição na síntese de sistemas assíncronos. Estas abordagens ou levam a uma otimização sub-ótima do sistema, porque usam algoritmos do paradigma síncrono ou usam procedimentos mais refinados, que dificultam o projeto. III. SÍNTESE COMPORTAMENTAL ASSÍNCRONA A síntese comportamental ou síntese de alto nível parte de uma especificação do tipo VHDL ou similar e gera uma descrição otimizada RTL. A Fig. 6 mostra os passos da síntese comportamental do método proposto. O método extrai da especificação o grafo de fluxo de dados e de controle [27] e aplica os algoritmos de escalonamento assíncrono, assinalamento de registradores e alocação de unidades funcionais Escalonamento assíncrono A tarefa de escalonamento é um problema de natureza combinatória, portanto é um problema NP-completo. Ela define o tempo inicial das operações sobre as restrições de recursos ou tempo. Através do escalonamento obtemos o número de operações que serão processadas por passo de controle, a sequência de operações e o número de passos de controle que a aplicação irá usar. Os algoritmos de escalonamento usam uma estrutura intermediária denominada grafo de fluxo de dados e de controle (GFDC) para descrever a sequência das operações e gerar um GFDC escalonado, isto é, definindo o número de passos de controle e as operações a cada passo. Muitos métodos propostos para síntese de sistemas assíncronos usam algoritmos de escalonamento do paradigma síncrono [7,10,11,14], com soluções sub-ótimas, porque o passo de controle representa um ciclo do clock, não existente paradigma assíncrono. O nosso método usa o algoritmo de escalonamento assíncrono exato proposto em [8] que é baseado em programação linear inteira (PLI). O algoritmo de [8] parte das restrições do número de unidades funcionais (UFs) analisa os atrasos das UFs e distribui as operações no menor número de passos. O escalonamento é definido pelas equações (1), (2), (3) e (4), onde a resolução deste sistema pode ser feita através da ferramenta Matlab ou pela ferramenta apresentada em [28]. A função objetivo para escalonamento com restrição de recursos é: Onde, r representa um recurso de uma dada biblioteca R, Custor representa o custo do recurso r, e Numr representa o número de recursos do tipo r. A função objetivo minimiza o custo total dos recursos do data-path sobre restrição do tempo. Há três tipos de restrição: a) Restrição de assinalamento do nó Cada nó i deve ser escalonado exatamente em um passo l∈Passoi . Esta restrição é representada como: b) Restrição de dependência Para cada arco direcionado (i,j) do GFD, devem ser satisfeitas as restrições de dependência: c) Restrição de assinalamento de recurso O número de operações executadas pelo recurso r no passo l deve ser igual a Num ou menor. A restrição de assinalamento de recurso é representada como segue: Onde: Nr é o conjunto de nós que está relacionado com o recurso r e Numr é um valor constante. Assinalamento de registradores e alocação de Ufs A tarefa de assinalamento de registradores procura compartilhar as variáveis usando o conceito de tempo de vida da variável. Esta tarefa também é um problema NPcompleto. O nosso método parte do grafo de compatibilidade e usa um algoritmo heurístico para encontrar sub-grafos que é muito simples e bastante eficiente [29]. O assinalamento das variáveis em um conjunto mínimo de registradores influencia diretamente as conexões, isto é no número de multiplexadores. A tarefa de alocação de unidades funcionais está relacionada com a escolha das operações com o operador (unidade funcional). O nosso método usa o grafo de compatibilidade para realizar esta tarefa. O algoritmo procura particionar o grafo em sub-grafos que tem o menor custo. Diferentes algoritmos existem para encontrar estes sub-grafos, por exemplo, algoritmos de coloração de grafo [29]. O nosso método usa o algoritmo de clique [29]. IV. SÍNTESE LÓGICA ASSÍNCRONA O controlador assíncrono é sintetizado no estilo de síntese lógica, que permite obter um controlador assíncrono otimizado. Fig. 7 mostra os três passos para a síntese lógica assíncrona. O nosso controlador assíncrono é descrito na especificação XBM, e obedece ao modelo de atraso bounded gate and wire delay, onde os atrasos são delimitados em mínimo e máximo. A interação com o ambiente ocorre no modo fundamental generalizado (MFG). No MFG, a cada ativação de uma nova entrada burst o controlador deve estar estabilizado, isto é sem atividade lógica. No nosso sistema assíncrono, tanto o data-path como o controlador opera no MFG; assim, na interação entre os dois blocos, eles devem estar estabilizados. O controlador XBM extraído pelo nosso método é sintetizado pela ferramenta 3D [24]. Esta ferramenta realiza dois passos, que são assinalamento de estados e minimização lógica. Ela implementa seus circuitos na arquitetura de Huffman com saída realimentada. Modo-burst estendido – XBM A especificação data-drive, proposta por Al Davis et al. [30] e formalizada por Nowick [31] como burst-mode (BM), é representada por um grafo na qual os vértices representam estados estáveis, enquanto os arcos representam as transições de estado. Um estado inicial deve existir. Yun e Dill [23,24] propuseram uma extensão no BM, denominada especificação modo-burst estendido (extended burst-mode – XBM) adicionando duas características: sinais irrelevantes (direct don’t-care) que permite um sinal de entrada seja ativado concorrentemente com os sinais de saída; e sinais condicionais que são sinais sensíveis ao nível com comportamento não monotônico) [23]. As restrições do BM foram generalizadas para permitir a extensão proposta em [23,24]. Nós ilustramos esta especificação com o benchmark Biudma2fifo da HP. Fig. 8 mostra uma especificação XBM com 4 entradas (cntgt1,dackn, fain,ok) , 2 saídas (dreq,frout) e o estado inicial 0. A descrição fain+ dackn+/ frout+ na transição 2→3 significa que a saída (frout: 0→1) vai seguir a entrada burst (fain: 0→1 AND dackn: 0→1). O sinal sensível ao nível cntgt1 é usado para descrever exclusão mútua entre as transições 1→5 e 1→2. O sinal irrelevante fain* na transição 0→1 significa que o sinal fain tanto pode alterar seu valor ou permanecer em seu valor antigo. V. MÉTODO: SISTEMAS ASSÍNCRONOS O método proposto segue os passos tradicionais da síntese comportamental e lógica, e implementa na arquitetura alvo da Fig. 1. A arquitetura usa o conversor de protocolo de [9], que permite com que a comunicação com o ambiente externo seja no protocolo de 2-Fases (ver Fig. 5). Fig. 9 mostra o fluxograma do método, que pode ser dividida em cinco passos: 1. Realiza a síntese comportamental assíncrona (ver seção II); gera o GFDC escalonado e o assinalamento de registradores e operadores (UFs). 2. A partir do passo (1) gerar o data-path inicial e a descrição do controlador XBM voltado para o protocolo de 4-Fases. 3. Transformar a especificação XBM de 4-Fases do controlador em 2-Fases; identificar e eliminar as transições de estado mortas. Uma transição de estado no XBM é definido como morta, quando a saida burst rotulada na transição não executa nenhuma operação, apenas muda de fase (chamada fase zero). 4. A partir do XBM de 2-Fases restruturar o data-path, substituindo componentes SET por componentes DET [9]. 5. Sintetizar a especificação XBM de 2-Fases do controlador utilizando a ferramenta 3D. VI. CASO DE ESTUDO O método proposto será ilustrado para o solucionador da equação diferencial de 2ª ordem: y’’+3xy’+3y=0 segundo o método de Euler. Fig. 10 mostra o pseudocódigo do método para solução [27]. O primeiro passo realiza a síntese comportamental, onde Fig. 11 mostra o sistema de equações PLI e a sua solução, que emprega dois multiplicadores e uma ULA. Fig. 12 mostra o GFDC escalonado final, com sete passos de controle. Fig. 12 também mostra dois diferentes tempos nos passos de controle, que são 2,8ns e 4,7ns. Fig. 13 mostra o assinalamento de registradores usando grafo de compatibilidade, no caso são oito SET-registradores. Fig. 14 mostra o assinalamento das Ufs, no caso dois multiplicadores e uma ULA, que realiza as operações de adição, subtração e comparação. O data-path inicial também contém oito bancos de multiplexadores. O segundo obtém a descrição do XBM de 4-Fases, que contém 22 estados, 23 transições de estado, 5 sinais de entrada e 24 sinais de saida. O terceiro passo identifica as transições mortas gerando a especificaçao XBM de 2-Fases; o novo XBM contém 11 estados, 12 transições de estado, 4 sinais de entrada e 21 sinais de saida (ver Fig. 15). O quarto passo reestrutura o data-path, que passa a ter seis registradores, sendo que os registradores R2 e R5 são DET (ver Fig. 16). O esquema geral do S_Euler_EDA está mostrado em Fig. 17, que resulta na inserção de dois elementos de atraso, relacionados com os dois tempos dos passos de controle. O passo final sintetiza o controlador na ferramenta 3D, na arquitetura de Huffman com saida realimentada. O circuito lógico é formado por 23 funções Booleanas soma de produto, onde duas variáveis de estado foram introduzidas. As 23 funções contêm 68 produtos e 179 literais. VII. RESULTADOS & SIMULAÇÃO A solução encontrada na seção VI foi sintetizada e simulada para uma FPGA STRATIX II da Altera (EP2S15F484C3) [32]. Fig. 18 mostra as formas de onda livre de hazard e os resultados obtidos de uma simulação. Neste caso, as entradas são: A=6; Dx=2; U=7; X=3; Y=10, obtendose a solução final Out=142. Fig. 19 mostra a simulaçao da versão síncrona do projeto S_Euler_ED. A Tabela 1 mostra os resultados de área da três versões do S_Euler_ED, incluindo a versão assíncrona obtida pelo método do Saito et al. [8] e, o tempo de processamento, que é obtido de Start + → End+ para os dados de entrada citados. A solução proposta para S_Euler_EDA obteve uma redução média no tempo de processamento de 30%. No requisito area, entretanto, teve uma penalidade de 40% no número de LUTS e uma penalidade de 31% no número de flip-flops, quando comparado com a versão síncrona. Comparando com a versão assíncrona do Saito, a nossa proposta teve uma penalidade de 18% no número de LUTS e uma redução de 2% no número de flip-flops. VIII. CONCLUSÃO Neste artigo apresentamos um método para projetar sistemas digitais assíncronos no estilo decomposição. Este estilo é familiar aos projetistas do paradigma síncrono. O método apresentado parte de um escalonamento assíncrono e usa componentes que operam nas duas bordas do sinal, permitindo uma redução significativa do número de transições de estado do XBM, o que acarreta um aumento de desempenho. Através de um caso bem conhecido que é S_Euler_SD, mostramos que o nosso método obtém resultado expressivo no tempo de processamento. Para trabalho futuro, é o desenvolvimento de uma ferramenta para o método proposto (síntese automática), permitindo aplicá-lo nos mais diferentes projetos."
}